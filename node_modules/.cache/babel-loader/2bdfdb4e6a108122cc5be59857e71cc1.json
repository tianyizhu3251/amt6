{"ast":null,"code":"/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n// Convenience function for converting NodeLists.\n\n/** @type {typeof Array.prototype.slice} */\nconst slice = Array.prototype.slice;\n/**\n * IE has a non-standard name for \"matches\".\n * @type {typeof Element.prototype.matches}\n */\n\nconst matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n/** @type {string} */\n\nconst _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n/**\n * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n * attribute.\n *\n * Its main functions are:\n *\n * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n *   instance exists for each focusable node which has at least one inert root as an ancestor.\n *\n * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n *   attribute is removed from the root node). This is handled in the destructor, which calls the\n *   `deregister` method on `InertManager` for each managed inert node.\n */\n\n\nclass InertRoot {\n  /**\n   * @param {!Element} rootElement The Element at the root of the inert subtree.\n   * @param {!InertManager} inertManager The global singleton InertManager object.\n   */\n  constructor(rootElement, inertManager) {\n    /** @type {!InertManager} */\n    this._inertManager = inertManager;\n    /** @type {!Element} */\n\n    this._rootElement = rootElement;\n    /**\n     * @type {!Set<!InertNode>}\n     * All managed focusable nodes in this InertRoot's subtree.\n     */\n\n    this._managedNodes = new Set(); // Make the subtree hidden from assistive technology\n\n    if (this._rootElement.hasAttribute('aria-hidden')) {\n      /** @type {?string} */\n      this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n    } else {\n      this._savedAriaHidden = null;\n    }\n\n    this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n\n\n    this._makeSubtreeUnfocusable(this._rootElement); // Watch for:\n    // - any additions in the subtree: make them unfocusable too\n    // - any removals from the subtree: remove them from this inert root's managed nodes\n    // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n    //   element, make that node a managed node.\n\n\n    this._observer = new MutationObserver(this._onMutation.bind(this));\n\n    this._observer.observe(this._rootElement, {\n      attributes: true,\n      childList: true,\n      subtree: true\n    });\n  }\n  /**\n   * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n   * stored in this object and updates the state of all of the managed nodes.\n   */\n\n\n  destructor() {\n    this._observer.disconnect();\n\n    if (this._rootElement) {\n      if (this._savedAriaHidden !== null) {\n        this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n      } else {\n        this._rootElement.removeAttribute('aria-hidden');\n      }\n    }\n\n    this._managedNodes.forEach(function (inertNode) {\n      this._unmanageNode(inertNode.node);\n    }, this); // Note we cast the nulls to the ANY type here because:\n    // 1) We want the class properties to be declared as non-null, or else we\n    //    need even more casts throughout this code. All bets are off if an\n    //    instance has been destroyed and a method is called.\n    // 2) We don't want to cast \"this\", because we want type-aware optimizations\n    //    to know which properties we're setting.\n\n\n    this._observer =\n    /** @type {?} */\n    null;\n    this._rootElement =\n    /** @type {?} */\n    null;\n    this._managedNodes =\n    /** @type {?} */\n    null;\n    this._inertManager =\n    /** @type {?} */\n    null;\n  }\n  /**\n   * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n   */\n\n\n  get managedNodes() {\n    return new Set(this._managedNodes);\n  }\n  /** @return {boolean} */\n\n\n  get hasSavedAriaHidden() {\n    return this._savedAriaHidden !== null;\n  }\n  /** @param {?string} ariaHidden */\n\n\n  set savedAriaHidden(ariaHidden) {\n    this._savedAriaHidden = ariaHidden;\n  }\n  /** @return {?string} */\n\n\n  get savedAriaHidden() {\n    return this._savedAriaHidden;\n  }\n  /**\n   * @param {!Node} startNode\n   */\n\n\n  _makeSubtreeUnfocusable(startNode) {\n    composedTreeWalk(startNode, node => this._visitNode(node));\n    let activeElement = document.activeElement;\n\n    if (!document.body.contains(startNode)) {\n      // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n      let node = startNode;\n      /** @type {!ShadowRoot|undefined} */\n\n      let root = undefined;\n\n      while (node) {\n        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n          root =\n          /** @type {!ShadowRoot} */\n          node;\n          break;\n        }\n\n        node = node.parentNode;\n      }\n\n      if (root) {\n        activeElement = root.activeElement;\n      }\n    }\n\n    if (startNode.contains(activeElement)) {\n      activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1\n      // calling blur() will not actually move the focus.\n      // To work around this we call focus() on the body instead.\n\n      if (activeElement === document.activeElement) {\n        document.body.focus();\n      }\n    }\n  }\n  /**\n   * @param {!Node} node\n   */\n\n\n  _visitNode(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n      return;\n    }\n\n    const element =\n    /** @type {!Element} */\n    node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n    // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n\n    if (element !== this._rootElement && element.hasAttribute('inert')) {\n      this._adoptInertRoot(element);\n    }\n\n    if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n      this._manageNode(element);\n    }\n  }\n  /**\n   * Register the given node with this InertRoot and with InertManager.\n   * @param {!Node} node\n   */\n\n\n  _manageNode(node) {\n    const inertNode = this._inertManager.register(node, this);\n\n    this._managedNodes.add(inertNode);\n  }\n  /**\n   * Unregister the given node with this InertRoot and with InertManager.\n   * @param {!Node} node\n   */\n\n\n  _unmanageNode(node) {\n    const inertNode = this._inertManager.deregister(node, this);\n\n    if (inertNode) {\n      this._managedNodes.delete(inertNode);\n    }\n  }\n  /**\n   * Unregister the entire subtree starting at `startNode`.\n   * @param {!Node} startNode\n   */\n\n\n  _unmanageSubtree(startNode) {\n    composedTreeWalk(startNode, node => this._unmanageNode(node));\n  }\n  /**\n   * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n   * @param {!Element} node\n   */\n\n\n  _adoptInertRoot(node) {\n    let inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,\n    // so register it now if need be.\n\n\n    if (!inertSubroot) {\n      this._inertManager.setInert(node, true);\n\n      inertSubroot = this._inertManager.getInertRoot(node);\n    }\n\n    inertSubroot.managedNodes.forEach(function (savedInertNode) {\n      this._manageNode(savedInertNode.node);\n    }, this);\n  }\n  /**\n   * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n   * @param {!Array<!MutationRecord>} records\n   * @param {!MutationObserver} self\n   */\n\n\n  _onMutation(records, self) {\n    records.forEach(function (record) {\n      const target =\n      /** @type {!Element} */\n      record.target;\n\n      if (record.type === 'childList') {\n        // Manage added nodes\n        slice.call(record.addedNodes).forEach(function (node) {\n          this._makeSubtreeUnfocusable(node);\n        }, this); // Un-manage removed nodes\n\n        slice.call(record.removedNodes).forEach(function (node) {\n          this._unmanageSubtree(node);\n        }, this);\n      } else if (record.type === 'attributes') {\n        if (record.attributeName === 'tabindex') {\n          // Re-initialise inert node if tabindex changes\n          this._manageNode(target);\n        } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n          // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n          // already managed nodes from this inert subroot.\n          this._adoptInertRoot(target);\n\n          const inertSubroot = this._inertManager.getInertRoot(target);\n\n          this._managedNodes.forEach(function (managedNode) {\n            if (target.contains(managedNode.node)) {\n              inertSubroot._manageNode(managedNode.node);\n            }\n          });\n        }\n      }\n    }, this);\n  }\n\n}\n/**\n * `InertNode` initialises and manages a single inert node.\n * A node is inert if it is a descendant of one or more inert root elements.\n *\n * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n * is intrinsically focusable or not.\n *\n * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n * or removes the `tabindex` attribute if the element is intrinsically focusable.\n */\n\n\nclass InertNode {\n  /**\n   * @param {!Node} node A focusable element to be made inert.\n   * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n   */\n  constructor(node, inertRoot) {\n    /** @type {!Node} */\n    this._node = node;\n    /** @type {boolean} */\n\n    this._overrodeFocusMethod = false;\n    /**\n     * @type {!Set<!InertRoot>} The set of descendant inert roots.\n     *    If and only if this set becomes empty, this node is no longer inert.\n     */\n\n    this._inertRoots = new Set([inertRoot]);\n    /** @type {?number} */\n\n    this._savedTabIndex = null;\n    /** @type {boolean} */\n\n    this._destroyed = false; // Save any prior tabindex info and make this node untabbable\n\n    this.ensureUntabbable();\n  }\n  /**\n   * Call this whenever this object is about to become obsolete.\n   * This makes the managed node focusable again and deletes all of the previously stored state.\n   */\n\n\n  destructor() {\n    this._throwIfDestroyed();\n\n    if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n      const element =\n      /** @type {!Element} */\n      this._node;\n\n      if (this._savedTabIndex !== null) {\n        element.setAttribute('tabindex', this._savedTabIndex);\n      } else {\n        element.removeAttribute('tabindex');\n      } // Use `delete` to restore native focus method.\n\n\n      if (this._overrodeFocusMethod) {\n        delete element.focus;\n      }\n    } // See note in InertRoot.destructor for why we cast these nulls to ANY.\n\n\n    this._node =\n    /** @type {?} */\n    null;\n    this._inertRoots =\n    /** @type {?} */\n    null;\n    this._destroyed = true;\n  }\n  /**\n   * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n   * If the object has been destroyed, any attempt to access it will cause an exception.\n   */\n\n\n  get destroyed() {\n    return (\n      /** @type {!InertNode} */\n      this._destroyed\n    );\n  }\n  /**\n   * Throw if user tries to access destroyed InertNode.\n   */\n\n\n  _throwIfDestroyed() {\n    if (this.destroyed) {\n      throw new Error('Trying to access destroyed InertNode');\n    }\n  }\n  /** @return {boolean} */\n\n\n  get hasSavedTabIndex() {\n    return this._savedTabIndex !== null;\n  }\n  /** @return {!Node} */\n\n\n  get node() {\n    this._throwIfDestroyed();\n\n    return this._node;\n  }\n  /** @param {?number} tabIndex */\n\n\n  set savedTabIndex(tabIndex) {\n    this._throwIfDestroyed();\n\n    this._savedTabIndex = tabIndex;\n  }\n  /** @return {?number} */\n\n\n  get savedTabIndex() {\n    this._throwIfDestroyed();\n\n    return this._savedTabIndex;\n  }\n  /** Save the existing tabindex value and make the node untabbable and unfocusable */\n\n\n  ensureUntabbable() {\n    if (this.node.nodeType !== Node.ELEMENT_NODE) {\n      return;\n    }\n\n    const element =\n    /** @type {!Element} */\n    this.node;\n\n    if (matches.call(element, _focusableElementsString)) {\n      if (\n      /** @type {!HTMLElement} */\n      element.tabIndex === -1 && this.hasSavedTabIndex) {\n        return;\n      }\n\n      if (element.hasAttribute('tabindex')) {\n        this._savedTabIndex =\n        /** @type {!HTMLElement} */\n        element.tabIndex;\n      }\n\n      element.setAttribute('tabindex', '-1');\n\n      if (element.nodeType === Node.ELEMENT_NODE) {\n        element.focus = function () {};\n\n        this._overrodeFocusMethod = true;\n      }\n    } else if (element.hasAttribute('tabindex')) {\n      this._savedTabIndex =\n      /** @type {!HTMLElement} */\n      element.tabIndex;\n      element.removeAttribute('tabindex');\n    }\n  }\n  /**\n   * Add another inert root to this inert node's set of managing inert roots.\n   * @param {!InertRoot} inertRoot\n   */\n\n\n  addInertRoot(inertRoot) {\n    this._throwIfDestroyed();\n\n    this._inertRoots.add(inertRoot);\n  }\n  /**\n   * Remove the given inert root from this inert node's set of managing inert roots.\n   * If the set of managing inert roots becomes empty, this node is no longer inert,\n   * so the object should be destroyed.\n   * @param {!InertRoot} inertRoot\n   */\n\n\n  removeInertRoot(inertRoot) {\n    this._throwIfDestroyed();\n\n    this._inertRoots.delete(inertRoot);\n\n    if (this._inertRoots.size === 0) {\n      this.destructor();\n    }\n  }\n\n}\n/**\n * InertManager is a per-document singleton object which manages all inert roots and nodes.\n *\n * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n * is created for each such node, via the `_managedNodes` map.\n */\n\n\nclass InertManager {\n  /**\n   * @param {!Document} document\n   */\n  constructor(document) {\n    if (!document) {\n      throw new Error('Missing required argument; InertManager needs to wrap a document.');\n    }\n    /** @type {!Document} */\n\n\n    this._document = document;\n    /**\n     * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n     * @type {!Map<!Node, !InertNode>}\n     */\n\n    this._managedNodes = new Map();\n    /**\n     * All inert roots known to this InertManager. In a map to allow looking up by Node.\n     * @type {!Map<!Node, !InertRoot>}\n     */\n\n    this._inertRoots = new Map();\n    /**\n     * Observer for mutations on `document.body`.\n     * @type {!MutationObserver}\n     */\n\n    this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.\n\n    addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.\n\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n    } else {\n      this._onDocumentLoaded();\n    }\n  }\n  /**\n   * Set whether the given element should be an inert root or not.\n   * @param {!Element} root\n   * @param {boolean} inert\n   */\n\n\n  setInert(root, inert) {\n    if (inert) {\n      if (this._inertRoots.has(root)) {\n        // element is already inert\n        return;\n      }\n\n      const inertRoot = new InertRoot(root, this);\n      root.setAttribute('inert', '');\n\n      this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.\n      // Ensure inert styles are added there.\n\n\n      if (!this._document.body.contains(root)) {\n        let parent = root.parentNode;\n\n        while (parent) {\n          if (parent.nodeType === 11) {\n            addInertStyle(parent);\n          }\n\n          parent = parent.parentNode;\n        }\n      }\n    } else {\n      if (!this._inertRoots.has(root)) {\n        // element is already non-inert\n        return;\n      }\n\n      const inertRoot = this._inertRoots.get(root);\n\n      inertRoot.destructor();\n\n      this._inertRoots.delete(root);\n\n      root.removeAttribute('inert');\n    }\n  }\n  /**\n   * Get the InertRoot object corresponding to the given inert root element, if any.\n   * @param {!Node} element\n   * @return {!InertRoot|undefined}\n   */\n\n\n  getInertRoot(element) {\n    return this._inertRoots.get(element);\n  }\n  /**\n   * Register the given InertRoot as managing the given node.\n   * In the case where the node has a previously existing inert root, this inert root will\n   * be added to its set of inert roots.\n   * @param {!Node} node\n   * @param {!InertRoot} inertRoot\n   * @return {!InertNode} inertNode\n   */\n\n\n  register(node, inertRoot) {\n    let inertNode = this._managedNodes.get(node);\n\n    if (inertNode !== undefined) {\n      // node was already in an inert subtree\n      inertNode.addInertRoot(inertRoot);\n    } else {\n      inertNode = new InertNode(node, inertRoot);\n    }\n\n    this._managedNodes.set(node, inertNode);\n\n    return inertNode;\n  }\n  /**\n   * De-register the given InertRoot as managing the given inert node.\n   * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n   * node from the InertManager's set of managed nodes if it is destroyed.\n   * If the node is not currently managed, this is essentially a no-op.\n   * @param {!Node} node\n   * @param {!InertRoot} inertRoot\n   * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n   */\n\n\n  deregister(node, inertRoot) {\n    const inertNode = this._managedNodes.get(node);\n\n    if (!inertNode) {\n      return null;\n    }\n\n    inertNode.removeInertRoot(inertRoot);\n\n    if (inertNode.destroyed) {\n      this._managedNodes.delete(node);\n    }\n\n    return inertNode;\n  }\n  /**\n   * Callback used when document has finished loading.\n   */\n\n\n  _onDocumentLoaded() {\n    // Find all inert roots in document and make them actually inert.\n    const inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n    inertElements.forEach(function (inertElement) {\n      this.setInert(inertElement, true);\n    }, this); // Comment this out to use programmatic API only.\n\n    this._observer.observe(this._document.body || this._document.documentElement, {\n      attributes: true,\n      subtree: true,\n      childList: true\n    });\n  }\n  /**\n   * Callback used when mutation observer detects attribute changes.\n   * @param {!Array<!MutationRecord>} records\n   * @param {!MutationObserver} self\n   */\n\n\n  _watchForInert(records, self) {\n    const _this = this;\n\n    records.forEach(function (record) {\n      switch (record.type) {\n        case 'childList':\n          slice.call(record.addedNodes).forEach(function (node) {\n            if (node.nodeType !== Node.ELEMENT_NODE) {\n              return;\n            }\n\n            const inertElements = slice.call(node.querySelectorAll('[inert]'));\n\n            if (matches.call(node, '[inert]')) {\n              inertElements.unshift(node);\n            }\n\n            inertElements.forEach(function (inertElement) {\n              this.setInert(inertElement, true);\n            }, _this);\n          }, _this);\n          break;\n\n        case 'attributes':\n          if (record.attributeName !== 'inert') {\n            return;\n          }\n\n          const target =\n          /** @type {!Element} */\n          record.target;\n          const inert = target.hasAttribute('inert');\n\n          _this.setInert(target, inert);\n\n          break;\n      }\n    }, this);\n  }\n\n}\n/**\n * Recursively walk the composed tree from |node|.\n * @param {!Node} node\n * @param {(function (!Element))=} callback Callback to be called for each element traversed,\n *     before descending into child nodes.\n * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n */\n\n\nfunction composedTreeWalk(node, callback, shadowRootAncestor) {\n  if (node.nodeType == Node.ELEMENT_NODE) {\n    const element =\n    /** @type {!Element} */\n    node;\n\n    if (callback) {\n      callback(element);\n    } // Descend into node:\n    // If it has a ShadowRoot, ignore all child elements - these will be picked\n    // up by the <content> or <shadow> elements. Descend straight into the\n    // ShadowRoot.\n\n\n    const shadowRoot =\n    /** @type {!HTMLElement} */\n    element.shadowRoot;\n\n    if (shadowRoot) {\n      composedTreeWalk(shadowRoot, callback, shadowRoot);\n      return;\n    } // If it is a <content> element, descend into distributed elements - these\n    // are elements from outside the shadow root which are rendered inside the\n    // shadow DOM.\n\n\n    if (element.localName == 'content') {\n      const content =\n      /** @type {!HTMLContentElement} */\n      element; // Verifies if ShadowDom v0 is supported.\n\n      const distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n\n      for (let i = 0; i < distributedNodes.length; i++) {\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n      }\n\n      return;\n    } // If it is a <slot> element, descend into assigned nodes - these\n    // are elements from outside the shadow root which are rendered inside the\n    // shadow DOM.\n\n\n    if (element.localName == 'slot') {\n      const slot =\n      /** @type {!HTMLSlotElement} */\n      element; // Verify if ShadowDom v1 is supported.\n\n      const distributedNodes = slot.assignedNodes ? slot.assignedNodes({\n        flatten: true\n      }) : [];\n\n      for (let i = 0; i < distributedNodes.length; i++) {\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n      }\n\n      return;\n    }\n  } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n  // element, nor a <shadow> element recurse normally.\n\n\n  let child = node.firstChild;\n\n  while (child != null) {\n    composedTreeWalk(child, callback, shadowRootAncestor);\n    child = child.nextSibling;\n  }\n}\n/**\n * Adds a style element to the node containing the inert specific styles\n * @param {!Node} node\n */\n\n\nfunction addInertStyle(node) {\n  if (node.querySelector('style#inert-style')) {\n    return;\n  }\n\n  const style = document.createElement('style');\n  style.setAttribute('id', 'inert-style');\n  style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  user-select: none;\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '}\\n';\n  node.appendChild(style);\n}\n/** @type {!InertManager} */\n\n\nconst inertManager = new InertManager(document);\n\nif (!Element.prototype.hasOwnProperty('inert')) {\n  Object.defineProperty(Element.prototype, 'inert', {\n    enumerable: true,\n\n    /** @this {!Element} */\n    get: function () {\n      return this.hasAttribute('inert');\n    },\n\n    /** @this {!Element} */\n    set: function (inert) {\n      inertManager.setInert(this, inert);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}